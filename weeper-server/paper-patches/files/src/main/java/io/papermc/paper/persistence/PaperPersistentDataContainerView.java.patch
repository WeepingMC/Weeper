--- a/src/main/java/io/papermc/paper/persistence/PaperPersistentDataContainerView.java
+++ b/src/main/java/io/papermc/paper/persistence/PaperPersistentDataContainerView.java
@@ -7,6 +_,7 @@
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
+import net.kyori.adventure.key.Key;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtIo;
 import net.minecraft.nbt.Tag;
@@ -36,7 +_,7 @@
     public abstract CompoundTag toTagCompound();
 
     @Override
-    public <P, C> boolean has(final NamespacedKey key, final PersistentDataType<P, C> type) {
+    public <P, C> boolean has(final Key key, final PersistentDataType<P, C> type) {
         Preconditions.checkArgument(key != null, "The NamespacedKey key cannot be null");
         Preconditions.checkArgument(type != null, "The provided type cannot be null");
 
@@ -49,13 +_,13 @@
     }
 
     @Override
-    public boolean has(final NamespacedKey key) {
+    public boolean has(final Key key) {
         Preconditions.checkArgument(key != null, "The provided key for the custom value was null"); // Paper
         return this.getTag(key.toString()) != null;
     }
 
     @Override
-    public <P, C> @Nullable C get(final NamespacedKey key, final PersistentDataType<P, C> type) {
+    public <P, C> @Nullable C get(final Key key, final PersistentDataType<P, C> type) {
         Preconditions.checkArgument(key != null, "The NamespacedKey key cannot be null");
         Preconditions.checkArgument(type != null, "The provided type cannot be null");
 
@@ -68,7 +_,7 @@
     }
 
     @Override
-    public <P, C> C getOrDefault(final NamespacedKey key, final PersistentDataType<P, C> type, final C defaultValue) {
+    public <P, C> C getOrDefault(final Key key, final PersistentDataType<P, C> type, final C defaultValue) {
         final C c = this.get(key, type);
         return c != null ? c : defaultValue;
     }
@@ -77,6 +_,19 @@
     public Set<NamespacedKey> getKeys() {
         final Set<String> names = this.toTagCompound().keySet();
         final Set<NamespacedKey> keys = new HashSet<>(names.size());
+        names.forEach(key -> {
+            final String[] keyPart = key.split(":", 2);
+            if (keyPart.length == 2) {
+                keys.add(new NamespacedKey(keyPart[0], keyPart[1]));
+            }
+        });
+        return Collections.unmodifiableSet(keys);
+    }
+
+    @Override
+    public Set<Key> keys() {
+        final Set<String> names = this.toTagCompound().keySet();
+        final Set<Key> keys = new HashSet<>(names.size());
         names.forEach(key -> {
             final String[] keyPart = key.split(":", 2);
             if (keyPart.length == 2) {
