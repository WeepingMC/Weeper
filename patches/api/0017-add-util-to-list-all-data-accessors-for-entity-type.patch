From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Yannick Lamprecht <yannicklamprecht@live.de>
Date: Wed, 20 Dec 2023 22:28:41 +0100
Subject: [PATCH] add util to list all data accessors for entity type


diff --git a/src/main/java/org/bukkit/EntityMetaResult.java b/src/main/java/org/bukkit/EntityMetaResult.java
new file mode 100644
index 0000000000000000000000000000000000000000..6b3b1fa911d22097a5976dc66156e50007527128
--- /dev/null
+++ b/src/main/java/org/bukkit/EntityMetaResult.java
@@ -0,0 +1,25 @@
+package org.bukkit;
+
+public interface EntityMetaResult {
+    int accessorId();
+
+    Class<?> entityClass();
+    Class<?> accessorGenericType();
+    Class<?> wrapperClass();
+
+    String deobfedName();
+
+    boolean isTypeGenericItself();
+
+    default String formattedString() {
+        return (isTypeGenericItself() ? wrapperClass().getSimpleName() + "<" : "") +
+            accessorGenericType().getSimpleName() +
+            (isTypeGenericItself() ? ">" : "");
+    }
+
+    default String formattedDeObfedString() {
+        return (isTypeGenericItself() ? wrapperClass().getSimpleName() + "<" : "") +
+            deobfedName() +
+            (isTypeGenericItself() ? ">" : "");
+    }
+}
diff --git a/src/main/java/org/bukkit/UnsafeValues.java b/src/main/java/org/bukkit/UnsafeValues.java
index a4b38f284d4fea7df7f9df9bf44e4f68fefaf20f..307ad69fe7d7274beea504e27ed76be7bc162a2f 100644
--- a/src/main/java/org/bukkit/UnsafeValues.java
+++ b/src/main/java/org/bukkit/UnsafeValues.java
@@ -260,4 +260,12 @@ public interface UnsafeValues {
 
     String getStatisticCriteriaKey(@NotNull org.bukkit.Statistic statistic);
     // Paper end
+
+    // Weeper start - entity data accessors
+    @NotNull
+    java.util.Set<Class<? extends org.bukkit.entity.Entity>> getAvailableBukkitEntityClasses();
+
+    @NotNull
+    <T extends org.bukkit.entity.Entity> java.util.Map<Integer, EntityMetaResult> getAllAccessors(@NotNull Class<T> clazz);
+    // Weeper end - entity data accessors
 }
diff --git a/src/main/java/org/bukkit/command/SimpleCommandMap.java b/src/main/java/org/bukkit/command/SimpleCommandMap.java
index ac9a28922f8a556944a4c3649d74c32c622f0cb0..47bcdd5e017487396288836d5e80c0fe1bfb4511 100644
--- a/src/main/java/org/bukkit/command/SimpleCommandMap.java
+++ b/src/main/java/org/bukkit/command/SimpleCommandMap.java
@@ -33,6 +33,7 @@ public class SimpleCommandMap implements CommandMap {
     private void setDefaultCommands() {
         register("bukkit", new VersionCommand("version"));
         register("bukkit", new ReloadCommand("reload"));
+        register("bukkit", new org.bukkit.command.defaults.ListAccessorCommand("entityacessor")); // Weeper - entity data accessors
         //register("bukkit", new PluginsCommand("plugins")); // Paper
         register("bukkit", new co.aikar.timings.TimingsCommand("timings")); // Paper
     }
diff --git a/src/main/java/org/bukkit/command/defaults/ListAccessorCommand.java b/src/main/java/org/bukkit/command/defaults/ListAccessorCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..384f6726f00b9cf1cae7ec2f6b5589c5bddc4454
--- /dev/null
+++ b/src/main/java/org/bukkit/command/defaults/ListAccessorCommand.java
@@ -0,0 +1,82 @@
+package org.bukkit.command.defaults;
+
+import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableList;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+import org.bukkit.Bukkit;
+import org.bukkit.EntityMetaResult;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.EntityType;
+import org.bukkit.entity.Player;
+import org.bukkit.util.StringUtil;
+import org.jetbrains.annotations.NotNull;
+
+public class ListAccessorCommand extends BukkitCommand {
+
+    public ListAccessorCommand(@NotNull String name) {
+        super(name);
+        this.description = "Gets a list of entity accessors";
+        this.usageMessage = "/entityacessor <entity";
+        this.setPermission("weeper.list.accessor");
+    }
+
+    @Override
+    public boolean execute(@NotNull CommandSender sender, @NotNull String commandLabel, @NotNull String[] args) {
+        if (args.length != 1) {
+            return false;
+        }
+
+        EntityType entityType = EntityType.fromName(args[0]);
+        if(entityType == EntityType.UNKNOWN) {
+            sender.sendMessage("EntityType."+entityType + "is not supported.");
+            return true;
+        }
+        long start = System.nanoTime();
+        Map<Integer, EntityMetaResult> allAccessors = Bukkit.getServer().getUnsafe().getAllAccessors(entityType.getEntityClass())
+            .entrySet()
+            .stream()
+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+
+        long result = System.nanoTime() - start;
+
+        if (!(sender instanceof Player player)) {
+            sender.sendMessage("Result generated in: " + result + " ns");
+            allAccessors.forEach((id, entityMetaResult) -> {
+                sender.sendMessage(id + ": " + entityMetaResult.formattedString());
+            });
+        } else {
+            player.sendRichMessage("<gold>Result generated in: " + result + " ns");
+            player.sendRichMessage("<dark_gray>id: <hover:show_text:\"<green>MojangName\"><gray>Type");
+            allAccessors.forEach((id, entityMetaResult) -> {
+                player.sendRichMessage("<dark_gray>" + id + ": <hover:show_text:\"<green>" + entityMetaResult.formattedDeObfedString() + "\"><gray>" + entityMetaResult.formattedString());
+            });
+        }
+
+        return true;
+    }
+
+    @Override
+    public @NotNull List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, @NotNull String[] args) throws IllegalArgumentException {
+        Preconditions.checkArgument(sender != null, "Sender cannot be null");
+        Preconditions.checkArgument(args != null, "Arguments cannot be null");
+        Preconditions.checkArgument(alias != null, "Alias cannot be null");
+
+        if (args.length == 1) {
+            List<String> completions = new ArrayList<>();
+            String toComplete = args[0].toLowerCase(java.util.Locale.ENGLISH);
+            for (EntityType value : EntityType.values()) {
+                if(value == EntityType.UNKNOWN) {
+                    continue;
+                }
+                if (StringUtil.startsWithIgnoreCase(value.name(), toComplete)) {
+                    completions.add(value.name());
+                }
+            }
+            return completions;
+        }
+        return ImmutableList.of();
+    }
+}
